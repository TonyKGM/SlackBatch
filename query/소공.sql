insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[정보화사업 예비타당성조사 제도]   ' , '	국가재정법, 사업비 500억, 국가재정지원규모 300억	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[폭포수 모델]   ' , '	순차적, 산출물중심, 단계적 테스팅, 정식변경절차수행(Frozen Delivery), 고전적 모델	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[프로토타이핑 모델]   ' , '	시제품, 의사소통, 실험적 프로토타입, 진화적 프로토타입	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Spiral 모델]   ' , '	계획 및 정의, 위험분석, 개발, 고객의 평가	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[반복적 개발 모델]   ' , '	점증적 반복, 증분형 (요구사항 명확, 병행), 진화형 (요구 불명확, N단계 진화)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[RAD(락스)]   ' , '	JRP, JAD, Construction Phase, Cutover	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Cleanroom software engineering]   ' , '	핵심영역을 증분형으로 개발하고 피드백 받아 다시 반복하여 개발	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[정형검증 (Formal Verification)]   ' , '	수학적 증명으로 오류 검증, Level 0, 1, 2, 모델체킹, 자동화된 정리증명	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[RUP]   ' , '	"Iterative, Incremental, Component based, Object-Oriented 개발방법론
개발싸이클은 4개의 Phase로 나뉨 (Inception > Elaboration > Construction > Transition), 4개의 Phase는 여러개의 반복(Iteration)으로 나뉠 수 있음."	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW 개발방법론]   ' , '	구조적 > 정보공학 > 90년대 객체지향 > CBD > Agile	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[구조적 개발방법론]   ' , '	"요구사항분석 > 구조적 분석 > 구조적 설계 > 구조적 프로그래밍
하향적 기능분해, 모듈화, Data Flow diagram, ERD, STD, Mini-Spec, DD, Structure Chart, 프로그램명세, Application 구조도, Multi-Level DFD, Database Table 기술서
3개 논리구조 : 연속 Sequence, 조건 If-Then-Else, 반복 Repetition"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[정보공학(IE) 방법론]   ' , '	"계획>분석>설계>수현 등 전과정 데이터 중심으로 정형화 시킨 데이터 중심 방법론
ISP 정보전략계획 > BAA 업무영역분석 > BSD업무시스템설계 > SC시스템 구축"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[객체지향 프로그래밍 특징]   ' , '	캡추다정상[캡슐화,추상화,다형성, 정보은닉, 상속성] 개체를 속성(attribute)와 메소드(method)로 결합된 형태의 객체로 표현	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[캡슐화(encapsulation)]   ' , '	객체의 속성과 행위를 하나로 묶고 실제 구현내용 일부를 감추어 은닉함	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[추상화]   ' , '	현실세계의 사실을 객체로 공통적인 속성과 기능을 묶어 이름을 부여함	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[다형성]   ' , '	같은 함수 이름으로 여러개의 메소드를 만드는 기법, Overriding, Overloading	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[정보은닉(Information Hiding)]   ' , '	캡슐화 방법으로 class내부 정보를 은닉하고 접근제한의 단계를 두어 보안적인 구현가능	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[상속성]   ' , '	상속은 클래스에서만 통용되는 개념으로 미리 만들어 둔 클래스를 다시 이용하는 방법	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[객체지향 설계의 원리]   ' , '	"SOLID
1.SRP (단일 책임의 원칙)
2.OCP (개방 폐쇄 원칙)
3.LIP (리스코프 치환의 원칙)
4.ISP (인터페이스 분리의 원칙)
5.DIP (의존성 역전의 원칙)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[객체지향 개발방법론]   ' , '	객체모델링 > 동적모델링 > 기능모델링 > 시스템설계 > 객체설계 > 구현 > 테스트	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[컴포넌트]   ' , '	개발단계 : 식별, 분석, 설계, 구현, 시험, 전개	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[CBD]   ' , '	생산성, 고품질, 재사용성과 대치성, 변경용이성, 기술집약성, 관리용이성, 사용자 중심	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Product Line]   ' , '	domain engineering, application engineering, core asset	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[도메인 공학]   ' , '	"재사용
도메인 정의 > 도메인 모델링 > 도메인 디자인 > 컴포넌트 구현"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[요구 공학]   ' , '	"요구공항 > 요구사항 > 요구사항 명세서
- 총체적인 접근 체계
- 요구사항 개발 프로세스 (추분명검)
- 요구사항 관리 프로세스 (협기변검)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[요구사항]   ' , '	"요구공항 > 요구사항 > 요구사항 명세서
- 요구사항 종류 나열 (시시명묵양성)
- 기능요구사항 - 목표동작, 개발 요구사항
- 비기능요구사항 - 시스템,인터페이스,데이터,테스트,보안,품질,제약,프로세스 
- 기타요구사항 - 유지관리, 인력, 컨설팅, 공사 (유인건설)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[요구사항명세서]   ' , '	"요구공항 > 요구사항 > 요구사항 명세서
- 명세원리 (정명일완수이검추)
- 요구사항 명세 
. 외부인터페이스, 기능,성능, 논리데이터베이스, 설계제약, 소프트웨어시스템 속성"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[페르소나(persona)]   ' , '	"- 요구사항 분석을 위한 페르소나 
- 페르소나 절차 
. 가상화 > 리서치 > 실체화 > 다양한요구사항 > 재구성"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[개발 방법론 테일러링(Tailoring)]   ' , '	"- 테일러링 프로세스 
. 프로젝트 특징 > 표준프로세스 선정 검증 > 상위수준 커스터마이징 > 세부 커스터 마이징 > 테일러링 문서화 
- 테일러링 고려사항 
. 범위, 플랫폼, 기반산출물, 숙련도, 발주사, 기술, 관리요소"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[AOP]   ' , '	"- 핵심과 횡단의 분리를 이루고 서로간의 Weaving통해 구현
. 핵심관심 : 단일 모듈의 주된 요구사항 (고객등록, 상품판매, 서비스해지)
. 횡단관심 : 여러 모듈의 공통 요구사항 (인증,보안,로깅)
- APO와 OOP 간의 비교"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Agile]   ' , '	RAXS	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[XP]   ' , '	아래 Agile로 정리 요망	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SCRUM]   ' , '	아래 Agile로 정리 요망	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW 발주 프로세스 총정리]   ' , '	SW 발주 프로세스 총정리	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[공공 소프트웨어 사업 제안 요청서 작성 가이드라인]   ' , '	"제안 평가(제안서 평가업무 처리규정)
제안요청서 작성 절차"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[요구사항 상세화 실무 가이드라인]   ' , '	"2018년 공공SW사업 제안요청서 작성을 위한 요구사항 상세화 실무가이드라인

[출처] 2018년 공공SW사업 제안요청서 작성을 위한 요구사항 상세화 실무가이드라인"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW 분리발주]   ' , '	5억 이상프로젝트, SW, HW 분리, GS인증	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW 분할발주]   ' , '	"공할, 공정, 기본설계, 상세설계이후로 구분
정보시스템 마스터플랜(ISMP: Information System Master Plan)
기능분할, 공정분할, 부품분할(기공부)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[원격지 개발]   ' , '	"발주처 인근에서 프로젝트를 수행하지 않고, 대면회의가 어려울 정도의 원격지에서 일부 또는 전체 프로젝트를

수행하는 SW 개발 방식"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[소프트웨어 산업 진흥법]   ' , '	소프트웨어 산업 진흥법 개정안 내용 숙지	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[조달청 협상에 의한 계약 제안서평가 세부기준]   ' , '	"조달청은 공공소프트웨어 사업 유형에 맞는 제안서 평가기준 마련을 위해 '조달청 협상에 의한 계약 제안서평가 세부기준'을 개정, 2019년 2월부터 시행.
-> 사업 유형별 특성을 반영하여 7개 유형으로 다양화 
- 정보화컨설팅사업 등 전체 암기"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[ESB]   ' , '	"Enterprise Service Bus
SOA 기반 표준화, XML 규격 통신
Interaction Link, SOAP, Runner 기술, ESB 패턴
CSB와 비교"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[웹서비스]   ' , '	"UDDI, SOAP, XML, REST, WSDL, JSON
역할 : Service Provider, Service Broker, Service Consumer"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[원격 프로스저 호출(RPC)]   ' , '	"IDL, Stub, XDR, 원격지 호출
동작 단계 : IDL 서버호출 규약 -> Client/Server에 Stub 빌드 -> Client에서 Stub 호출->
Stub에서 RPC -> Server 수신함수 처리 및 반환 -> Client 결과 수신"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW Architecture]   ' , '	"프로그램/시스템 컴포넌트 간의 상호관계 구조
SW Architecture 이용하여 품질 및 생산성 향상
구성요소 : Architecture Description(AD), 이해관계자, 관심사, 관점, View"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','["ISO/IEC/IEEE 42010
(구 버전 IEEE1471)"]   ' , '	"시스템, 소프트웨어 및 엔터프라이즈 아키텍처 설명에 대한 요구사항 / 표준용어정의
식별 : System of Interest(대상 시스템), Stakeholder(이해관계자), Concerns(관심사)
표현 : Model Kind(모델형), Architecture(아키텍처), Architecture description(아키텍처 기술)
AD 파트 : Architectual Viewpoint(아키텍처 View 관점), Architecture View(아키텍처 뷰), 
Architecture Model(모델), Architecture Rationale(결정 근거), 
Correspondence Rule(대응 관계의 규제), Correspondence(대응 관계)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW Architecture 평가]   ' , '	"소프트웨어 아키텍처의 정방향 분석, 소프트웨어 아키텍처의 역방향 분석
시나리오 기반 평가모델 : SAAM, CBAM, ATAM, EATAM
설계 / 혼합 기반 평가 모델 : ADR, ARID"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[ATAM]   ' , '	"ISO9126 평가요소
ATAM Phase 0~4
평가단계 - 소조테보
소개 - 조사와분석 - 테스트 - 보고
"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[CBAM]   ' , '	"CBAM 프로세스
시나리오결정 - 효용반응값 곡선작성 - 아키텍처 접근법 전체이익 계산 - 아키텍처 접근법 선정과 검증
"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Architecture Driver]   ' , '	Functional Requirements, Constraints, Quality Attributes	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[모델 / 패턴]   ' , '	"아키텍처 스타일 유형
DBR, DBP, VIR, CMR
Data-Centered - blackboard, repository
Data Flow - Batch Sequence, Pipes and filters
Virtual Machine - Interpreter, Rule-Based System
Call and Return - Main Program and subroutine, Remote Procedure call"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Blackboard pattern]   ' , '	해결전략이 없는 문제를 해결하기 위한 패턴	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[4+1 View Model]   ' , '	Logical View, Implementation View, Process View, Deployment View, User-Case View	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SAD]   ' , '	SAD(SW Architecture Description)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[MSA]   ' , '	"마이크로서비스 아키텍처(MicroService Architecture)
Monolithic Architecture"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[clean architecture]   ' , '	"Robert Martin은 clean architecture를
컴포넌트 응집도 3가지 원칙
REP, CCP, CRP"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SW Architect]   ' , '	소프트웨어아키텍처 스타일	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[MDA]   ' , '	MOF, UML, CWM, XMI, PIM, PSM	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[MDD]   ' , '	PIM, PSM, MDD개발절차, 매핑	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Spring Framwork]   ' , '	"자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크.
대한민국 공공기관의 웹 서비스 개발 시 사용을 권장하고 있는 전자정부 표준프레임워크의 기반 기술
1. 제어 반전 컨테이너/(IoC: Inversion of Control) 컨테이너
2. 관점 지향 프로그래밍(AOP)을 지원
2. 데이터 액세스 프레임워크/스프링은 데이터베이스에 접속하고 자료를 저장 및 읽어오기 위한 여러 가지 유명한 라이브러리, 즉 JDBC, iBATIS(MyBatis), Hibernate 등에 대한 지원 기능을 제공하여 데이터베이스 프로그래밍을 쉽게 사용.
4. Spring MVC라 불리는 모델-뷰-컨트롤러(MVC) 패턴을 사용"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[7개 서비스 그룹/38개 서비스]   ' , '	7개 서비스 그룹/38개 서비스 총정리	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[IoC(Inversion of Control)]   ' , '	"기존의 프로그래밍에서 객체의 생성, 제어, 소멸 등의 객체의 라이프 사이클을 개발자가 관리 하던 것을 컨테이너에게 그 제어권을 위임하는 프로그래밍 기법
- DL(Dependency Lookup) : 의존성 검색. 저장소에 저장되어 있는 빈(Bean)에 접근하기 위하여 개발자들이 컨테이너에서 제공하는 API를 이용하여 사용하고자 하는 빈(Bean)을 Lookup하는 것
- DI(Dependency Injection) : Setter Injection, Constructor Injection, Interface Injection, Method Injectio"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Diagram]   ' , '	"전체 다이어그램 구분 정리
구조 기반 / 행위 기반 다이어 그램
15개 다이어그램을 2.x로 분류할 수 있는가? 목록 정의만 할것"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[UML의 관계(Relationship)]   ' , '	"의존관계, 연관관계, 일반화(Generalization), 실체화(Realization) 
연의GR"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Stereotype]   ' , '	"UML 스테레오 타입(stereotype)
길러멧(Guillemet) 기호
코드 변환 사례 참조"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Activity diagram]   ' , '	"-객체간의 제어 흐름, 동적뷰, 구획면(Swim Lane), 활동, 전이, Fork & Join, 분기, 병행 프로세스 1) 시작상태, 2) 활동, 3) 종료상태, 4) 선택점, 5) 전이 6) 병렬작업 분기, 7) 병렬작업 합류
- 처리 로직이나 조건에 따른 객체 간의 제어 흐름을 중점적으로 보여 주는 Workflow 흐름도"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[State Machine diagram]   ' , '	스테이트 머신 다이어그램(state machine diagram)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[State Diagram]   ' , '	(구성요소)시작,종료,상태,전이,이벤트,전이조건	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Usecase diagram]   ' , '	"-Actor, include, extend, Generalization, Association, Grouping, 직관적 사용자 대화수단
-시스템이 제공하고 있는 기능 및 그와 관련된 외부요소를 사용자의 관점에서 표현하는 다이어그램"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Sequence diagram]   ' , '	"-액터,활성객체,메시지,제어사각형
-객체를 정의하고 한 Usecase내에 포함된 객체 간의 상호작용을 시간 순서로 표현하는 동적 다이어그램"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Class diagram]   ' , '	"-클래스, 속성(Attribute), 연산(Operation), 연관, 집합연관, 복합연관, 의존, 상속, 구현
-시스템을 구성하는 객체의 타입을 정의하고, 그 타입들 간의 존재하는 관계를 표현하는 정적 다이어그램"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Component diagram]   ' , '	구조 다이어그램, 컴포넌트, 인터페이스, 의존 관계, 지원 관계	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Composite Structure Diagram]   ' , '	클래스 실행, 내부 구조	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Deployment diagram]   ' , '	하드웨어에 소프트웨어 배치, 노드, 연결, 관계	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Interaction diagram]   ' , '	객체들 간의 상호작용, 시퀀스 다이어그램, 통신 다이어그램, 인터랙션 개요 다이어그램, 타이밍 다이어그램	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Interaction overview Diagram]   ' , '	UML 2.0, Sequence와 Activity의 결합, 시작 / 활동 / 종료 / 선택점 / 전이	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Timing Diagram]   ' , '	시간제약 초점, 객체 / 상태 / 사건 / 상태변화 / 시간제약	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Communication Diagram]   ' , '	"객체간 상호작용을 관계에 초점을 두고 표현한 동적 다이어그램
구성 : 활성객체, 관계(링크, 메시지, 메시지 번호), 프레임, 생명선
메시지 상태 : 동기적, 비동기적, 생성, 답신"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Feature diagram]   ' , '	"종속성을 정의하는 모델
구성 : Mandatory(필수), Optional(선택), Alternative(대체), or, And
4가지 종류의 레이아웃 : Manual Layout, Abego Layout, Legend Auto-Layout, Constraints Auto-Layout"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[UML 2.0 / 2.X 최종 확인]   ' , '	"소프트웨어 집약 시스템의 시각적 모델을 만들기 위한 표준화된 도안 표기법
메타모델 구성 : M3 (Meta-Meta Model),M2 (Meta Model), M1 (User Model),M0 (Run-Time Instance)
변경 : Communication, State machine
신규 : Composite Structure (Architecture), Interaction, Overview, Package, Timing"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[UML Profile]   ' , '	"UML 표현 기법을 추가 정의하여 다양한 모델을 정확히 표현할 수 있게 한 UML의 확장 메커니즘
확장 메커니즘 : Stereotypes, TagDefinitions, Tagged, Values, Constraints
"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[MOF]   ' , '	"객체 지향 모델 작성에 사용되는 UML 메타 모델의 필수 요소와 문법, 구조를 정의하는 메타 모델. 객체 및 컴포넌트 기술의 핵심을 정형화한 모델
메타모델 구성 : 구성 : M3 (Meta-Meta Model),M2 (Meta Model), M1 (User Model),M0 (Run-Time Instance)
MDA 구성 : MOF(Meta Object Facility), UML(Unified Modeling Language), CWM(Common Warehouse Metamodel) 
XMI(XML Metadata Interface) 
"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[OCL]   ' , '	"객체지향 모델요소에 대한 제약조건을 기술하기 위해 OMG에서 채택한 명세언어
제약조건 : 불변조건, 선행조건, 후행조건"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[추상클래스]   ' , '	"- 주로 상속관계에서 추상적인 개념을 표현하고, 하나 이상의 완성되지 않은 메소드를 가지고 있는 클래스 
키워드 : non-static, non-final, abstract(선언), extends(상속), 단일상속"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[인터페이스(클래스)]   ' , '	"- 구현부와 선언부 분리 개발, 클래스 연결, Interface, implements, 
기능을 모아놓은 클래스로, 추상 매서드와 상수만을 포함하는 추상 클래스
- 키워드 : static, final, public 만 가능, interface(선언), Implements(상속)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','["Design Pattern
(23개 패턴)"]   ' , '	생구행 (아비프로시파(ABProSiFa), ABCD파플로(ABCDFaFlro), CMI(CCMMII) 쏘티브(SSOTV))	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Hollywood Principle]   ' , '	"- 고수준 구성요소를 통해 저수준 구성요소 사용 결정한다는 의존성 부패 방지 원칙 
- 키워드 : 의존성 부패, 템플릿메소드패턴, 추상클래스"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Abstract Factory 패턴]   ' , '	"- 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 
집합을 생성할 수 있는 인터페이스를 제공 
- 키워드 : 팩토리를 추상화, 인터페이스를 이용 
"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Builder 패턴]   ' , '	"- 제품을 여러 단계로 나눠서 만들 수 있도록 제품 생산 단계들을 캡슐화 
- 키워드 : 객체 생성에 대한 일관성 부여, 객체 생성, 작게 분리 
단계를 캡슐화"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Prototype 패턴]   ' , '	"프로토타입 패턴;
기존 인스턴스를 복사하기만 하면, 새로운 인스턴스를 만들수 있는 패턴
(자바에서는 clone( ) 메소드를 이용하면 됨)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Singleton 패턴]   ' , '	"싱글톤 패턴; 오직 단 하나의 인스턴스만을 생성하고 전역변수 사용과 같이 어디서나 인스턴스에 접근 가능한 디자인 패턴으로 이 인스턴스에 접근할 수 있는 포인트(Point)을 제공하는 패턴.
public static Singleton getInstance() 
static의 정의: Singleton.getInstance()로 접근가능하게 만듬"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Factory method 패턴]   ' , '	"팩토리 메서드 패턴; 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들어지는 서브클래스에서 결정하게 한다.
- 의존관계를 구체클래스에서 결정

팩토리 메서드 패턴을 이용하면, 클래스의 인스턴스 만드는 일을 서브클래스에게 맡기는 것이 됨.
자바소스 확인
Class Diagram 그릴 것"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Adaptor 패턴]   ' , '	"ABCD퍼플로(ABCDFaFlro)
어댑터 패턴; 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다.
어댑터를 이용하면, 인터페이스 호환성 문제 때문에 같이 쓸 수 없는
클래스들을 연결해서 쓸 수 있다."	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Bridge 패턴]   ' , '	"브릿지 패턴, 혹은 브리지패턴
- 구현 뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우에는 브릿지 패턴을 사용.
- 추상화된 부분과 추상 클래스, 인터페이스를 구현한 클래스를 서로 다른 클래스 계층에 넣어, 분리
- 장점: 구현과 인터페이스 분리. 단점: 디자인이 복잡"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Composite 패턴]   ' , '	"복합 패턴; 혹은 컴포지트 패턴
객체들을 트리 구조로 구성하여, 부분과 전체를 나타내는 계층 구조를 만들 수 있음. (예)음식의 메뉴 설계 시에, MunuComponent를 MenuItem과 Menu가 상속받아, getName( ), getPrice( )처리"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Decorator 패턴]   ' , '	"상속없이 동적으로 기능 추가
Component(상위 클래스), ConcreteComponent(하위 클래스),
Decorator(상위클래스), ConcreteDecorator(하위 클래스)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Façade 패턴]   ' , '	"인터페이스를 모아서 처리
다수 객체들의 인터페이스 집합에 대해 일관괸 인터페이스를 제공
1:M 구현"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Flyweight 패턴]   ' , '	"종류별로 분할하여 공유해서 사용
작은 객체들을 효과적으로 사용하기 위해 공유 개념 도입"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Proxy 패턴]   ' , '	"중개 대리자
Remote Proxy, Virtual Proxy, Protection Proxy, Smart Reference"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Chain of responsibility 패턴]   ' , '	메시지를 보내는 객체와 이를 처리하는 객체간 결합도를 없애기 위한 패턴.	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Command 패턴]   ' , '	"요청을 객체화
Command, ConcreteCommand, Client, Invoker, Receiver"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Mediator 패턴]   ' , '	"미디에이터 패턴
- 객체들 간의 상호작용을 분리하여 캡슐화 함으로써 상호작용의 유연한 변경을 지원하는 행위패턴"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Memento 패턴]   ' , '	"메멘토 패턴
객체를 이전의 상태로 복구 시켜야하는 경우에는 메멘토 패턴을 쓰면 됨.
예를 들어, 사용자가 “작업 취소”를 요청하는 경우를 생각하면 됨"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Interpreter 패턴]   ' , '	"인터프리터 패턴
문법 자체를 캡슐화하여 문법 검사와 함께 필요한 동작을 수행할 수 있는 방법을 제공하는 행위패턴"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Iterator 패턴]   ' , '	"이터레이터 패턴
내부 구조를 노출하지 않고 복합 객체의 원소를 순차적으로 접근할 수 있도록 해주는 행위패턴."	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[State]   ' , '	"스테이트 패턴, 객체의 상태
상태가 변경될 때 마다 별도의 행위를 지정해야 되는 객체를 정의 및 조직화 
하는 방법을 제공하는 행위패턴
Client 상태에서 발생 가능한 상태(온, 오프 등)마다 수행되는 클래스
(전략패턴와 유사, 상태에 최적화)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Strategy pattern]   ' , '	"전략 패턴 - Select Box 생각
알고리즘 군을 정의하고, 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 조건에 따라서, 유사 알고리즘 기능 구현
전략패턴을 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 
알고리즘을 변경할 수 있다.(Family of algorithm)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Observer]   ' , '	"옵저버, 일대다(one-to-many), subject, push model, pull model
Push Model: observer는 subject를 subscribe하며 모든 데이터를 받음
Pull Model: observer가 데이터 필요시 Getter 메소드를 이용 subject에서 데이터 받음"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Template Method]   ' , '	알고리즘의 골격 정의, AbstractClass, abstractOperation, final Method, extends	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Visitor 패턴]   ' , '	데이터 구조와 기능처리 분리(캡슐화 위배), Visitor 인터페이스, Element 인터페이스, 개방-폐쇄의 원칙	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[MVC 패턴]   ' , '	"MVC(Model, View, Controller) 
재사용 향상을 위한 SW 아키텍처 패턴"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[서킷 브레이커(Circuit Breaker) 패턴]   ' , '	"Open: 오류 상태 
Closed: 서비스가 정상 동작하는 상태 
Half Open: 서비스 상태 체크하는 중간 상태"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[TDD]   ' , '	"Test Driven Development (테스트 자동화 적용 사례)
요구사항에 기반한 Test case 우선 제작하고 실제 코드는 리펙토링 반복하며 구현"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[코드 스멜]   ' , '	코드 스멜, 코드 리팩토링, Rename, Encapsulation, Pull up, 코딩오류 vs 코드스멜	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[클린코드(Clean Code)]   ' , '	중복없음, 가독성, 클린코드 vs 코드스멜, 작성방법(이름, 함수, 주석, 형식, 오류)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Code 유형]   ' , '	문제정의, 해결방안, Clean Up, 인스팩션, McCabe, CI연계	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[DevOps]   ' , '	Plan, Code, Build, Test, Release, Deploy, Monitoring 반복, 상호작용, CI/CD 도구 사용	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[SRE(Site Reliability Engineering)]   ' , '	"안정성, 자가치유, 자동화, 카나리 배포, Toil 관리, Error Budget, 구글 운영팀
SLO = SLI + 목표값(Goal),"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Test 일반]   ' , '	"Test Bed, Test Target,Test Harness(Test Driver, Test Stub), 화이트박스 테스트,
블랙박스테스트, 마이어의 원칙"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 유형]   ' , '	화이트박스, 블랙박스, 동적, 정적, 검증, 확인, 단위, 통합, 시스템, 인수, 설치, 기능, 구조, 회귀, 뱅형, 부하, 성능, 유지보수, 안전, 회복, 강도, 레코드, 테스트 오라클, 리스크 기반, 페어와이즈, 준거성, 실증성, 명세기반, 구조기반, 경험기반	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 차터]   ' , '	승인서, 범위/목적, 세션/일정, 대상/절차, 결함/이슈, 경험	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 원리]   ' , '	결함발견, 불완전, 초기 시작, 결함 집중, 살충제 패러독스, 정황의존, 오류부재 궤변	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[V-Model]   ' , '	단위, 통합, 시험, 인수, Validation, Verification, Water Fall Model 테스트	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트베드(Testbed)]   ' , '	테스트 하네스, 테스트 드라이버 , 테스트 스텁	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 단계 분류]   ' , '	단위, 통합, 시스템, 인수/설치 테스트, 테스트하네스(드라이버, 스텁)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 정보 획득 분류]   ' , '	"회화부(화이트, 블랙박스테스트)
화이트 박스, 블랙박스 테스트"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[프로그램 실행여부]   ' , '	"동적(화이트박스, 블랙박스테스트)
정적(코드검사, 워크스루)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[블랙박스 테스트]   ' , '	"블랙박스테스트 = 명세기반테스트 
동치분해의 원칙(equivalence partitioning)
1) 범위보다 작은 값, 범위 내의 값, 범위를 넘어서는 큰 값 
2) 정상 입력에 속하는 값, 그 외의 값
- 동등(클래스) 분할(Equivalence Class Partitioning), 경계값 분석(Boundary Value Analysis), 
의사결정(Decision table testing), 
상태전이(State transition testing), 유스케이스(Usecase testing)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[명세기반 테스팅 기법]   ' , '	"Specification-based or Black-box Techniques
- 테스트 케이스를 모델로부터 체계적으로 도출, 문서기반
- 동등클래스 분할(Equivalence Class Partitioning), 경계값 분석(Boundary Value Analysis), 
의사결정(Decision table testing), 
상태전이(State transition testing), 유스케이스(Usecase testing)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','["화이트박스테스트
(White Box Test)"]   ' , '	"화이트박스테스트 = 구조기반테스트
제어구조시험, 루프시험, Coverage, MC/DC
화이트 박스 테스트: clear box testing, glass box testing, transparent box testing, and structural testing라고 혼용함"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[구조기반테스트]   ' , '	"구조기반 테스트(Structure-based or White box techniques)
Coverage, MC/DC"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[탐색적 테스팅]   ' , '	Heuristic기반, 테스트 차터, Time-boxing, 테스트노트, 테스트세션, 요약보고	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 자동화]   ' , '	도구활용, 시간과 자원의 제약 극복 품질향상, 설계(명세기반/코드기반/테스트 관리 도구), 구현(정적분석, 리뷰, 커버리지 측정, 동적분석, 성능, 시뮬레이션 도구)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Regression Test]   ' , '	riffle effect, side effect, retest all/selective/priority	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[테스트 오라클]   ' , '	참, 샘플링, 휴리스틱, 일관성 검사	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[MC/DC]   ' , '	결과 독립적, N+1	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Crowdingsourcing Test]   ' , '	대중, Usage, Beta, System, Functional	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[Compliance Test]   ' , '	준거성 테스트(Compliance Test), 실증성 테스트(Substantive Test)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[모델기반 테스트]   ' , '	요구사항으로부터 테스트 모델을 구축하고 이를 테스트 기준으로 활용하여 테스트케이스(TC)를 자동 생성	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[경험기반 기법]   ' , '	"테스트 관련 인력의 지식이나 경험으로 테스트 케이스를 도출
탐색적 테스팅, 오류추정, 체크리스트, 분류트리"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[뮤테이션 테스트]   ' , '	"Mutation 기법(소스코드 변경하여 테스트하는 기법)
변경한 소스 코드를 뮤턴트(Mutant)라고 함.
목적: 새 프로그램의 품질을 평가하기 위해서 함.(보안 아님!!)"	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[사용성 테스트]   ' , '	사용성 테스트(Usability Testing)	 ');
insert into slackpush.exam (gubun,problem,keyword) values('ONE_TYPE','[빅뱅테스트(Bigbang Test)]   ' , '	빅뱅테스트(Bigbang Test)	 ');